一、缓存更新策略：解决缓存数据一致性问题
    1.内存淘汰
    ——原理：利用Redis的内存淘汰机制，当内存不走时自动淘汰部分数据，下次查询时更新缓存。
    ——特点：一致性差，无维护成本

    2.超时淘汰：
    ——原理：给缓存数据添加TTL时间，到期后自动删除缓存；下次查询时更新缓存；
    ——特点：一致性一般，维护成本低；

    3.主动更新：延迟双删，且设置过期时间
    ——原理：编写业务逻辑，在修改数据库时，更新缓存。
    ——特点：一致性好，维护成本高。


二、缓存穿透
    缓存穿透是指客户都请求的数据在缓存和数据库中都没有，造成所有的请求都打到数据库中。

    1.解决方法——缓存空对象且设置TTL
    ————可能造成短期的数据不一致

    2.解决方法——布隆过滤

三、缓存雪崩
    缓存雪崩是指同一时间段大量的缓存key同时失效，或者Redis服务宕机，导致大量请求到达数据库

    1.解决方法
    ——给不同的key的TTL添加随机值；
    ——利用Redis集群提高服务的可用性；
    ——给缓存业务添加降级限流策略；
    ——给业务添加多级缓存（Nginx缓存、本地缓存、Redis缓存、DB缓存）；

三、缓存击穿
    缓存击穿问题，又叫热点key问题，一个被高并发访问并且缓存重建业务比较复杂的key突然失效，导致大量的请求在瞬间到达数据库。

    解决方式：
    1.利用互斥锁: 保证了数据一致性，但性能较差、可能出险死锁
        T1: 查询缓存未命中——获取互斥锁成功——查询数据库重建缓存数据——写入缓存——释放锁
        T2:     查询缓存未命中——获取互斥锁失败——sleep()——重试——缓存命中

    2.逻辑过期：性能较好，但存在短期的数据不一致，实现复杂
        T1: 查询缓存，发现逻辑时间已过期——获取互斥锁成功——开启子线程T2——返回过期数据给客户端
        T2:                                       查询数据库重建缓存数据——写入缓存，重置逻辑过期时间——释放锁
        T3:             查询缓存，发现逻辑时间过期——获取互斥锁失败——返回过期数据给客户端。




